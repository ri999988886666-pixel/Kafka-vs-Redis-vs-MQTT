import redis
import json
import time
from typing import Optional, Dict, Any

class RedisService:
    def __init__(self):
        self.redis_client = redis.Redis(
            host='localhost',
            port=6379,
            db=0,
            decode_responses=True
        )
        self.pubsub = self.redis_client.pubsub()
    
    # –ö–≠–®–ò–†–û–í–ê–ù–ò–ï
    def cache_user_data(self, user_id: str, user_data: Dict[str, Any], ttl: int = 3600):
        """–ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        key = f"user:{user_id}"
        self.redis_client.setex(
            key, 
            ttl, 
            json.dumps(user_data)
        )
        print(f"‚úÖ User {user_id} cached for {ttl}s")
    
    def get_cached_user(self, user_id: str) -> Optional[Dict[str, Any]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∫—ç—à–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        key = f"user:{user_id}"
        data = self.redis_client.get(key)
        if data:
            return json.loads(data)
        return None
    
    # PUB/SUB –î–õ–Ø REAL-TIME
    def publish_order_update(self, order_id: str, status: str, user_id: str):
        """–ü—É–±–ª–∏–∫–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–∞"""
        message = {
            "order_id": order_id,
            "status": status,
            "user_id": user_id,
            "timestamp": time.time()
        }
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –∫–∞–Ω–∞–ª –æ–±–Ω–æ–≤–ª–µ–Ω–∏–π –∑–∞–∫–∞–∑–æ–≤
        self.redis_client.publish(
            "order_updates", 
            json.dumps(message)
        )
        
        # –û—Ç–ø—Ä–∞–≤–∫–∞ –≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏–π –∫–∞–Ω–∞–ª
        self.redis_client.publish(
            f"user:{user_id}:orders",
            json.dumps(message)
        )
        
        print(f"üì¢ Order update published: {order_id} -> {status}")
    
    def subscribe_to_orders(self, callback):
        """–ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –∑–∞–∫–∞–∑–æ–≤"""
        self.pubsub.subscribe("order_updates")
        print("üîî Subscribed to order updates")
        
        for message in self.pubsub.listen():
            if message['type'] == 'message':
                order_data = json.loads(message['data'])
                callback(order_data)
    
    # –û–ß–ï–†–ï–î–ò –ó–ê–î–ê–ß
    def add_to_queue(self, queue_name: str, task_data: Dict[str, Any]):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ –∑–∞–¥–∞—á–∏ –≤ –æ—á–µ—Ä–µ–¥—å"""
        self.redis_client.lpush(
            queue_name, 
            json.dumps(task_data)
        )
        print(f"üì• Task added to {queue_name}")
    
    def process_queue(self, queue_name: str, callback):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∑–∞–¥–∞—á –∏–∑ –æ—á–µ—Ä–µ–¥–∏"""
        print(f"üîÑ Processing queue: {queue_name}")
        
        while True:
            # BRPOP –±–ª–æ–∫–∏—Ä—É–µ—Ç—Å—è –¥–æ –ø–æ—è–≤–ª–µ–Ω–∏—è –∑–∞–¥–∞—á–∏
            _, task_json = self.redis_client.brpop(queue_name, timeout=0)
            task_data = json.loads(task_json)
            callback(task_data)

# –ü—Ä–∏–º–µ—Ä –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
def handle_order_update(order_data):
    print(f"üéØ Received order update: {order_data}")

def process_background_task(task_data):
    print(f"üõ†Ô∏è Processing task: {task_data}")

if __name__ == "__main__":
    service = RedisService()
    
    # –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
    user_data = {"name": "John Doe", "email": "john@example.com"}
    service.cache_user_data("user_123", user_data)
    
    # –ü–æ–ª—É—á–µ–Ω–∏–µ –∏–∑ –∫—ç—à–∞
    cached_user = service.get_cached_user("user_123")
    print(f"üìã Cached user: {cached_user}")
    
    # –ü—É–±–ª–∏–∫–∞—Ü–∏—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è
    service.publish_order_update("order_001", "shipped", "user_123")
    
    # –î–æ–±–∞–≤–ª–µ–Ω–∏–µ –≤ –æ—á–µ—Ä–µ–¥—å
    service.add_to_queue("background_tasks", {"type": "email", "to": "user@example.com"})
    
    # –ó–∞–ø—É—Å–∫ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º –ø–æ—Ç–æ–∫–µ
    import threading
    thread = threading.Thread(
        target=service.process_queue, 
        args=("background_tasks", process_background_task)
    )
    thread.daemon = True
    thread.start()
    
    # –ü–æ–¥–ø–∏—Å–∫–∞ –Ω–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è (–±–ª–æ–∫–∏—Ä—É—é—â–∏–π –≤—ã–∑–æ–≤)
    service.subscribe_to_orders(handle_order_update)